# Copyright Â© [2023,] 2023, Oracle and/or its affiliates.
"""Logging configuration for vLLM."""
import inspect
import json
import logging
import os
import sys
import time
import traceback
from pathlib import Path
from typing import Optional

from loguru import logger


class InterceptHandler(logging.Handler):
    """A custom logging handler for intercepting logs and redirecting them.

    This handler is designed to integrate with loguru's `logger` library,
    capturing log records generated by Python's standard logging module and
    processing them using `logger`.

    Attributes:
        loglevel_mapping (dict): Mapping of logging level numbers to string
            representations.
    """

    loglevel_mapping = {
        50: "CRITICAL",
        40: "ERROR",
        30: "WARNING",
        20: "INFO",
        10: "DEBUG",
        0: "NOTSET",
    }

    def format_exc_info(self, exc_info):
        """
        Formats the exception information from exc_info tuple into a string.

        This function takes the exception information tuple from sys.exc_info,
        and formats it into a human-readable traceback string.

        Args:
            exc_info (tuple): A tuple containing (exc_type, exc_value,
                exc_traceback), which represents the type, value, and traceback
                of an exception.
        """
        exc_type, exc_value, exc_traceback = exc_info
        tb_lines = traceback.format_exception(exc_type, exc_value,
                                              exc_traceback)
        return "".join(tb_lines)

    def emit(self, record: logging.LogRecord):
        """Process the logging record.

        Overrides the default emit method to handle log records. It binds the
        logger to a specific name and adds contextual information.

        Args:
            record (logging.LogRecord): The log record to process.
        """
        try:
            level = logger.level(record.levelname).name
        except AttributeError:
            level = self.loglevel_mapping[record.levelno]

        frame, depth = inspect.currentframe(), 0
        while frame and (depth == 0
                         or frame.f_code.co_filename == logging.__file__):
            frame = frame.f_back
            depth += 1

        if record.exc_info:
            formatted_traceback = self.format_exc_info(record.exc_info)
            message = f"{record.getMessage()}\n{formatted_traceback}"
        else:
            message = record.getMessage()

        if hasattr(record, "opc-request-id"):
            opc_request_id = getattr(record, "opc-request-id")
            logger.opt(depth=depth).log(level,
                                        message,
                                        opc_request_id=opc_request_id)
        else:
            logger.opt(depth=depth).log(level, message)


class CustomizeLogger:
    """A class for configuring and customizing logging.

    Provides methods for setting up structured and unstructured logging,
    including log rotation, retention, and formatting.

    Methods are class methods, allowing direct access without instantiation.
    """

    @classmethod
    def make_logger(cls, config_path: Path):
        """Create and configure a logger based on a configuration file.

        Args:
            config_path (Path): Path to the configuration file.

        Returns:
            Logger: Configured logger instance.
        """
        config = cls.load_logging_config(config_path)
        logging_config = config.get("logger")

        logger = cls.customize_logging(
            structured_filepath=logging_config.get("structured_log_file_path"),
            unstructured_filepath=logging_config.get(
                "unstructured_log_file_path"),
            level=logging_config.get("level"),
            retention=logging_config.get("retention"),
            rotation=logging_config.get("rotation"),
            format=logging_config.get("format"),
        )

        return logger

    @classmethod
    def serialize(cls, record):
        """Serialize a log record to JSON.

        Args:
            record (dict): The log record to serialize.

        Returns:
            str: The serialized JSON string.
        """
        error, exception = "", record["exception"]
        if exception:
            type, ex, tb = exception
            error = (f" {type.__name__}: {ex}\n"
                     f"{''.join(traceback.format_tb(tb))}")

        subset = {
            "module": record["module"],
            "pathname": record["file"].name,
            "lineno": record["line"],
            "thread": record["thread"].id,
            "extra_info": record["extra"],
            "funcName": record["function"],
            "ts": int(time.time() * 1000),
            "level": record["level"].name,
            "msg": record["message"] + error,
        }

        # Add 'opc_request_id' to the structured log if it exists
        opc_request_id = record["extra"].get("opc_request_id", None)
        if opc_request_id:
            subset["opc-request-id"] = opc_request_id

        return json.dumps(subset)

    @classmethod
    def formatter(cls, record):
        """Format a log record for structured logging.

        Note: This function returns the string to be formatted, not the actual
        message to be logged.

        Args:
            record (dict): The log record to format.

        Returns:
            str: The formatted log record.
        """
        record["extra"]["serialized"] = cls.serialize(record)
        return "{extra[serialized]}\n"

    @classmethod
    def customize_logging(
        cls,
        structured_filepath: Optional[Path] = None,
        unstructured_filepath: Optional[Path] = None,
        level: str = "INFO",
        rotation: Optional[str] = None,
        retention: Optional[str] = None,
        format: Optional[str] = None,
    ) -> logging.Logger:
        """Customize logging setup based on configuration options.

        Configures logging with options for both structured and unstructured
        log files, including rotation, retention, and formatting. Allows
        enabling/disabling file logging and structured logging.

        Args:
            structured_filepath (Optional[Path]): Path to the structured log
                file.
            unstructured_filepath (Optional[Path]): Path to the unstructured
                log file.
            level (str): Logging level.
            rotation (Optional[str]): Log rotation policy.
            retention (Optional[str]): Log retention policy.
            format (Optional[str]): Log format.

        Returns:
            logging.Logger: Configured logger instance.
        """
        logger.remove()

        # Default format if none provided
        default_format = ("<level>{level: <8}</level> "
                          "<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> - "
                          "<cyan>{name}</cyan>:<cyan>{function}</cyan> - "
                          "<level>{message}</level>")
        log_format = format or default_format

        # Console output configuration
        logger.add(
            sys.stderr,
            enqueue=True,
            backtrace=True,
            level=level.upper(),
            format=log_format,
        )

        # File logging configuration
        if unstructured_filepath:
            # Unstructured file logging configuration
            logger.add(
                str(unstructured_filepath),
                rotation=rotation,
                retention=retention,
                enqueue=True,
                backtrace=True,
                level=level.upper(),
                serialize=False,
                format=log_format,
            )
        if structured_filepath:
            # Structured file logging configuration
            logger.add(
                str(structured_filepath),
                rotation=rotation,
                retention=retention,
                enqueue=True,
                backtrace=True,
                level=level.upper(),
                serialize=False,
                format=cls.formatter,
            )

        # Basic configuration for intercepting standard logging messages
        std_logger = logging.getLogger()
        std_logger.setLevel(logging.getLevelName(level.upper()))
        std_logger.addHandler(InterceptHandler())
        std_logger.propagate = False

        return std_logger

    @classmethod
    def load_logging_config(cls, config_path: Path):
        """Load logging configuration from a JSON file.

        Args:
            config_path (Path): Path to the configuration file.

        Returns:
            dict: Loaded configuration.
        """
        config = None
        with open(config_path) as config_file:
            config = json.load(config_file)
        return config


dir_path = os.path.dirname(os.path.realpath(__file__))
config_path = f"{dir_path}/default_logging_config.json"
_root_logger = CustomizeLogger.make_logger(Path(config_path))


def init_logger(name: str):
    return _root_logger.getChild(name)
